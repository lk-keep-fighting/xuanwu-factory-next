# AI Coding Execution Service Design

## 1. 背景与目标
本模块旨在根据用户的自然语言意图描述以及 Git 仓库地址，自动完成源码获取、智能编码实现、结果提交，并在整个生命周期内通过 Webhook 定时推送进度信息。设计目标包括：

- 可靠地拉取并管理外部 Git 仓库源码。
- 结合意图描述，驱动智能体进行分析、规划与编码实现。
- 自动化执行测试、提交并推送变更。
- 通过可配置的 Webhook 定时上报状态，保证过程透明可追踪。
- 具备安全隔离、可扩展与可观测的工程化能力。

## 2. 整体架构
系统划分为以下关键组件：

1. **Task Orchestrator（任务编排器）**
   - 提供 API 接口，接收“意图描述 + Git 仓库链接 + Webhook 配置”等参数。
   - 校验输入合法性，并持久化任务元数据（数据库或 KV 存储）。
   - 将任务推入队列，调度工作节点执行。

2. **Repository Manager（仓库管理器）**
   - 负责从远程仓库克隆、拉取或更新代码。
   - 管理多任务的临时工作目录，支持凭证、子模块等高级特性。
   - 提供 Git 操作封装（创建分支、提交、推送）。

3. **AI Coding Worker（智能编码工作流）**
   - 消费任务队列，读取意图与仓库上下文。
   - 调用 LLM/Agent 框架执行“理解 -> 规划 -> 修改 -> 验证”的循环。
   - 引入工具层：文件读写器、代码搜索器、测试执行器等。
   - 实现异常兜底（回滚、重试、人工介入通道）。

4. **Execution Sandbox（执行沙箱）**
   - 通过容器或轻量 VM 隔离运行环境，保证依赖安装、测试执行、安全策略。
   - 提供资源配额 & 超时控制。

5. **Webhook Scheduler（Webhook 调度器）**
   - 根据任务配置定时（如 cron/固定间隔）触发状态上报。
   - 聚合任务实时数据，构建 payload，通过签名加密后投递至下游。

6. **Observability & Storage**
   - 日志（结构化 + trace）、指标（Prometheus）、事件（Task 状态机）。
   - Artifact 存储：任务报告、diff 结果、测试日志等。

整体可以通过微服务或模块化单体实现，核心是任务编排 + Agent 工作流 + 安全执行环境。

## 3. 详细流程

1. **任务创建**
   - API 接口接收请求（intent、repo、分支策略、Webhook 频率、鉴权信息）。
   - 校验 Git 地址可访问性、Webhook URL 合法性，生成任务 ID。
   - 持久化任务，写入消息队列（如 Redis Stream, RabbitMQ, Kafka）。

2. **仓库准备**
   - Worker 拉取任务后，向 Repository Manager 请求工作目录。
   - 克隆远程仓库（支持 SSH/HTTPS，必要时注入凭证）。
   - 按任务策略创建工作分支 `feat/ai-task-<id>`。

3. **智能体执行**
   - 解析意图：基于 LLM 提取需求、关键文件、验收标准。
   - 生成执行计划并记录到任务上下文（可保存于数据库）。
   - 进入迭代循环：
     1. **分析上下文**：使用代码检索工具定位相关文件。
     2. **编辑实现**：通过受控文件写入操作完成代码修改。
     3. **验证**：运行必要的测试/构建脚本，收集结果。
     4. **评估**：若未满足验收或出现错误，更新计划并重试，设定最大迭代次数与超时。

4. **结果提交**
   - 所有修改完成后，执行 `git status` 校验。
   - 生成结构化任务报告（变更摘要、测试结果、diff 列表）。
   - 提交并推送到远端（可选：发起 Pull Request/ Merge Request）。

5. **Webhook 推送**
   - Webhook Scheduler 周期性获取任务状态（排队中、执行中、测试、提交、完成、失败等）。
   - 发送包含任务元数据、阶段信息、错误详情或进度百分比的 JSON。
   - 提供签名和重试策略，保证可靠传输。

6. **任务收尾**
   - 清理工作目录与临时凭证。
   - 将最终结果写入任务记录，允许用户查询历史。

## 4. 技术选型建议

- **后端框架**：Node.js (NestJS) / Python (FastAPI) 等，支持快速构建 API 与任务调度。
- **队列系统**：Redis + BullMQ / RabbitMQ / Celery 视现有栈而定。
- **Agent 框架**：LangChain、OpenAI Function Calling、self-hosted LLM 等，实现可扩展的工具组合。
- **执行环境**：Docker in Docker / Kubernetes Job，结合安全策略（只读基础镜像、资源限制）。
- **存储**：PostgreSQL/MySQL（任务、日志元数据）；对象存储（Artifact）；Redis（状态缓存）。
- **Webhook 调度**：基于调度器（Quartz、BullMQ repeatable jobs、K8s CronJob）或内置定时器。
- **鉴权与安全**：
  - Git 凭证加密存储，仅任务执行时解密加载。
  - Webhook 签名（HMAC）+ HTTPS。
  - 任务环境隔离，防出网策略。

## 5. 关键工程点

- **任务状态机**：定义清晰的状态与转换，便于监控与告警。
- **可观测性**：为每个阶段记录日志、指标，支持链路追踪（例如 OpenTelemetry）。
- **失败处理**：
  - 仓库克隆失败：重试 + 告警。
  - LLM 执行失败：回退上一版本，提供人工接管入口。
  - Webhook 投递失败：指数退避 + 死信队列。
- **扩展能力**：
  - 支持多模型、多工具插件化。
  - 可配置测试策略（全量、增量、跳过）。
  - 支持 PR 注释、代码审查辅助等增值功能。

## 6. 实施阶段划分

1. **MVP**
   - 支持单任务串行执行，基础 Git 获取与提交。
   - 简单的 LLM 调用链，执行少量测试。
   - Webhook 固定间隔推送（如每 1 分钟）。

2. **增强阶段**
   - 引入队列，支持并发任务。
   - 丰富状态机与观察性数据。
   - 增加失败重试、超时控制。

3. **企业级完善**
   - 多租户、权限体系。
   - 动态资源调度与算力池。
   - 自定义工作流、扩展工具市场。

## 7. 后续工作

- 根据业务场景补充安全合规审计流程。
- 制定模型调用成本控制策略（限额、预算）。
- 设计可视化任务面板，支持人工干预与回放。
- 编写详细的 API / Webhook 文档与示例。
